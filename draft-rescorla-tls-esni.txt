



tls                                                          E. Rescorla
Internet-Draft                                                RTFM, Inc.
Intended status: Experimental                               May 12, 2018
Expires: November 13, 2018


              Encrypted Server Name Indication for TLS 1.3
                     draft-rescorla-tls-esni-latest

Abstract

   This document defines a simple mechanism for encrypting the Server
   Name Indication for TLS 1.3.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on November 13, 2018.

Copyright Notice

   Copyright (c) 2018 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.






Rescorla                Expires November 13, 2018               [Page 1]

Internet-Draft           TLS 1.3 SNI Encryption                 May 2018


Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2
   2.  Conventions and Definitions . . . . . . . . . . . . . . . . .   3
   3.  Overview  . . . . . . . . . . . . . . . . . . . . . . . . . .   3
     3.1.  Topologies  . . . . . . . . . . . . . . . . . . . . . . .   4
     3.2.  SNI Encryption  . . . . . . . . . . . . . . . . . . . . .   4
   4.  Publishing the SNI Encryption Key . . . . . . . . . . . . . .   5
   5.  The "encrypted_server_name" extension . . . . . . . . . . . .   6
     5.1.  Client Behavior . . . . . . . . . . . . . . . . . . . . .   7
     5.2.  Fronting Server Behavior  . . . . . . . . . . . . . . . .   8
     5.3.  Hidden Server Behavior  . . . . . . . . . . . . . . . . .   9
   6.  Compatibility Issues  . . . . . . . . . . . . . . . . . . . .   9
     6.1.  Misconfiguration  . . . . . . . . . . . . . . . . . . . .   9
     6.2.  Middleboxes . . . . . . . . . . . . . . . . . . . . . . .   9
   7.  Security Considerations . . . . . . . . . . . . . . . . . . .  10
     7.1.  Why is cleartext DNS OK?  . . . . . . . . . . . . . . . .  10
     7.2.  Comparison Against Criteria . . . . . . . . . . . . . . .  10
       7.2.1.  Mitigate against replay attacks . . . . . . . . . . .  10
       7.2.2.  Avoid widely-deployed shared secrets  . . . . . . . .  11
       7.2.3.  Prevent SNI-based DoS attacks . . . . . . . . . . . .  11
       7.2.4.  Do not stick out  . . . . . . . . . . . . . . . . . .  11
       7.2.5.  Forward secrecy . . . . . . . . . . . . . . . . . . .  11
       7.2.6.  Proper security context . . . . . . . . . . . . . . .  11
       7.2.7.  Fronting server spoofing  . . . . . . . . . . . . . .  12
       7.2.8.  Supporting multiple protocols . . . . . . . . . . . .  12
     7.3.  Misrouting  . . . . . . . . . . . . . . . . . . . . . . .  12
   8.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  12
   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  12
     9.1.  Normative References  . . . . . . . . . . . . . . . . . .  12
     9.2.  Informative References  . . . . . . . . . . . . . . . . .  13
   Appendix A.  Communicating SNI to Hidden Server . . . . . . . . .  14
   Appendix B.  Alternate Encryption Design  . . . . . . . . . . . .  14
   Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . . .  15
   Author's Address  . . . . . . . . . . . . . . . . . . . . . . . .  15

1.  Introduction

   DISCLAIMER: This is very early a work-in-progress design and has not
   yet seen significant (or really any) security analysis.  It should
   not be used as a basis for building production systems.

   Although TLS 1.3 [I-D.ietf-tls-tls13] encrypts most of the handshake,
   including the server certificate, there are several other channels
   that allow an on-path attacker to determine domain name the client is
   trying to connect to, including:

   o  Cleartext client DNS queries.



Rescorla                Expires November 13, 2018               [Page 2]

Internet-Draft           TLS 1.3 SNI Encryption                 May 2018


   o  Visible server IP addresses, assuming the the server is not doing
      domain-based virtual hosting.

   o  Cleartext Server Name Indication (SNI) [RFC6066] in ClientHello
      messages.

   DoH [I-D.ietf-doh-dns-over-https] and DPRIVE [RFC7858] [RFC8094]
   provide mechanisms for clients to conceal DNS lookups from network
   inspection, and many TLS servers host multiple domains on the same IP
   address.  In such environments, SNI is an explicit signal used to
   determine the server's identity.  Indirect mechanisms such as traffic
   analysis also exist.

   The TLS WG has extensively studied the problem of protecting SNI, but
   has been unable to develop a completely generic solution.
   [I-D.ietf-tls-sni-encryption] provides a description of the problem
   space and some of the proposed techniques.  One of the more difficult
   problems is "Do not stick out" ([I-D.ietf-tls-sni-encryption];
   Section 2.4): if only hidden services use SNI encryption, then SNI
   encryption is a signal that a client is going to a hidden server.
   For this reason, much recent work has focused on concealing the fact
   that SNI is being protected.  Unfortunately, the result often has
   undesirable performance consequences, incomplete coverage, or both.

   The design in this document takes a different approach: it assumes
   that hidden servers will hide behind a provider (CDN, app server,
   etc.) which is able to activate encrypted SNI (ESNI) for all of the
   domains it hosts.  Thus, the use of encrypted SNI does not indicate
   that the client is attempting to reach a hidden server, but only that
   it is going to a particular service provider, which the observer
   could already tell from the IP address.

2.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in BCP
   14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

3.  Overview

   This document is designed to operate in one of two primary topologies
   shown below, which we call "Shared Mode" and "Fronting Mode"







Rescorla                Expires November 13, 2018               [Page 3]

Internet-Draft           TLS 1.3 SNI Encryption                 May 2018


3.1.  Topologies

                   +--------------------+
                   |                    |
                   |   2001:DB8::1111   |
                   |                    |
   Client <----->  | hidden.example.org |
                   |                    |
                   | public.example.com |
                   |                    |
                   +--------------------+
                           Server

                      Figure 1: Shared Mode Topology

   In Shared Mode, the provider is the origin server for all the domains
   whose DNS records point to it and clients form a TLS connection
   directly to that provider, which has access to the plaintext of the
   connection.

                   +--------------------+       +--------------------+
                   |                    |       |                    |
                   |   2001:DB8::1111   |       |   2001:DB8::EEEE   |
   Client <------------------------------------>|                    |
                   | public.example.com |       | hidden.example.com |
                   |                    |       |                    |
                   +--------------------+       +--------------------+
                       Fronting Server               Hidden Server

                     Figure 2: Fronting Mode Topology

   In Fronting Mode, the provider is _not_ the origin server for hidden
   domains.  Rather the DNS records for hidden domains point to the
   provider, but the provider's server just relays the connection back
   to the hidden server, which is the true origin server.  The provider
   does not have access to the plaintext of the connection.  In
   principle, the provider might not be the origin for any domains, but
   as a practical matter, it is probably the origin for a large set of
   innocuous domains, but is also providing protection for some hidden
   domains.  Note that the hidden server can be an unmodified TLS 1.3
   server.

3.2.  SNI Encryption

   The protocol designed in this document is quite straightforward.

   First, the provider publishes a public key which is used for SNI
   encryption for all the domains which it serves or fronts for.  This



Rescorla                Expires November 13, 2018               [Page 4]

Internet-Draft           TLS 1.3 SNI Encryption                 May 2018


   document defines a publication mechanism using DNS, but other
   mechanisms are also possible.  In particular, if some of the clients
   of a hidden server are applications rather than Web browsers, those
   applications might have the public key preconfigured.

   When a client wants to form a TLS connection to any of the domains
   served by an ESNI-supporting provider, it replaces the "server_name"
   extension in the ClientHello with an "encrypted_server_name"
   extension, which contains the true extension encrypted under the
   provider's public key.  The provider can then decrypt the extension
   and either terminate the connection (in Shared Mode) or forward it to
   the hidden server (in Fronting Mode).

4.  Publishing the SNI Encryption Key

   SNI Encryption keys can be published in the DNS using the ESNIKeys
   structure, defined below.

       // Copied from TLS 1.3
       struct {
           NamedGroup group;
           opaque key_exchange<1..2^16-1>;
       } KeyShareEntry;

       struct {
           opaque label<0..2^8-1>;
           KeyShareEntry share;
       } ESNIKeyShare;

       struct {
           ESNIKeyShareEntry keys<4..2^16-1>;
           CipherSuite cipher_suites<2..2^16-2>;
           uint16 padded_length;
       } ESNIKeys;

   label  An opaque label to use for a given key.

   share  An (EC)DH key share (attached to the label)

   keys  The list of keys which can be used by the client to encrypt the
      SNI.

   padded_length  The length to pad the ServerNameList value to prior to
      encryption.  This value SHOULD be set to the largest
      ServerNameList the fronting server expects to support rounded up
      the nearest multiple of 16.





Rescorla                Expires November 13, 2018               [Page 5]

Internet-Draft           TLS 1.3 SNI Encryption                 May 2018


   [[OPEN ISSUE: An alternative to padding is to instead send a hash of
   the server name.  This would be fixed-length, but have the
   disadvantage that the server has to retain a table of all the server
   names it supports.]]

   The semantics of this structure are simple: any of the listed keys
   may be used to encrypt the SNI for the associated domain name.  The
   cipher suite list is orthogonal to the list of keys, so each key may
   be used with any cipher suite.

   This structure is placed in the RRData section of a TXT record as
   encoded above.  The name of each TXT record MUST match the name
   composed of "_esni" and the query domain name.  That is, if a client
   queries example.com, the ESNI TXT name is _esni.example.com.  Servers
   SHOULD configure DNS such that, upon querying a domain name with ESNI
   support, at most one each of A, AAAA, TXT ESNI, and ALTSVC
   [I-D.schwartz-httpbis-dns-alt-svc] Resource Record is returned.  Alt-
   Svc records may be used to inform the client of the plaintext
   (fronting) SNI.  Also, servers operating in Fronting Mode SHOULD have
   DNS configured to return the same A (or AAAA) record for all hidden
   servers they service.

   The Resource Record TTL determines the lifetime of the published ESNI
   keys.  Clients MUST NOT use ESNI keys beyond their published
   lifetime.  Note that the length of this structure MUST NOT exceed
   2^16 - 1, as the RDLENGTH is only 16 bits [RFC1035].

5.  The "encrypted_server_name" extension

   The encrypted SNI is carried in an "encrypted_server_name" extension,
   which contains an EncryptedSNI structure:

      struct {
          opaque label<0..2^8-1>;
          CipherSuite suite;
          opaque encrypted_sni<0..2^16-1>;
      } EncryptedSNI;

   label  The label associated with the SNI encryption key.

   suite  The cipher suite used to encrypt the SNI.

   encrypted_sni  The original ServerNameList from the "server_name"
      extension, padded and AEAD-encrypted using cipher suite "suite"
      and with the key generated as described below.






Rescorla                Expires November 13, 2018               [Page 6]

Internet-Draft           TLS 1.3 SNI Encryption                 May 2018


5.1.  Client Behavior

   In order to send an encrypted SNI, the client MUST first select one
   of the server ESNIKeyShare values and generate an (EC)DHE share in
   the matching group.  If multiple keys (labels) for the same IP
   address are available, clients SHOULD choose one at random.  This
   share is then used for the client's "key_share" extension and will be
   used both to derive both the SNI encryption key the (EC)DHE shared
   secret which is used in the TLS key schedule.  This has two important
   implications:

   o  The client MUST only provide one KeyShareEntry

   o  The server is committing to support every group in the ESNIKeys
      list (see below for server behavior).

   The SNI encryption key is computed from the DH shared secret Z as
   follows:

   Zx = HKDF-Extract(0, Z)
   key = HKDF-Expand-Label(Zx, "esni key", ClientHello.Random, key_length)
   iv = HKDF-Expand-Label(Zx, "esni iv", ClientHello.Random, iv_length)

   The client then creates a PaddedServerNameList:

      struct {
          ServerNameList sni;
          opaque zeros[padding_length - length(sni)];
      } PaddedServerNameList;

   This value consists of the serialized ServerNameList padded with
   enough zeroes to make the total structure ESNIKeys.padded_length
   bytes long.  The purpose of the padding is to prevent attackers from
   using the length of the "encrypted_server_name" extension to
   determine the true SNI.  If the serialized ServerNameList is longer
   than ESNIKeys.padded_length, the client MUST NOT use the
   "encrypted_server_name" extension.

   The EncryptedSNI.encrypted_sni value is then computed using the usual
   TLS 1.3 AEAD:

       encrypted_sni = AEAD-Encrypt(key, iv, "", PaddedServerNameList)

   Note: future extensions may end up reusing the server's ESNIKeyShare
   for other purposes within the same message (e.g., encrypting other
   values).  Those usages MUST have their own HKDF labels to avoid
   reuse.




Rescorla                Expires November 13, 2018               [Page 7]

Internet-Draft           TLS 1.3 SNI Encryption                 May 2018


   [[OPEN ISSUE: If in future you were to reuse these keys for 0-RTT
   priming, then you would have to worry about potentially expanding
   twice of Z_extracted.  We should think about how to harmonize these
   to make sure that we maintain key separation.]]

   This value is placed in an "encrypted_server_name" extension.

   The client MAY either omit the "server_name" extension or provide an
   innocuous dummy one (this is required for technical conformance with
   [RFC7540]; Section 9.2.)

5.2.  Fronting Server Behavior

   Upon receiving an "encrypted_server_name" extension, the server MUST
   first perform the following checks:

   o  If it is unable to negotiate TLS 1.3 or greater, it MUST abort the
      connection with a "handshake_failure" alert.

   o  If the EncryptedSNI.label value does not correspond to any known
      SNI encryption key, it MUST abort the connection with an
      "illegal_parameter" alert.  [[OPEN ISSUE: We looked at ignoring
      the extension but concluded this was better.]]

   o  If more than one KeyShareEntry has been provided, or if that
      share's group does not match that for the SNI encryption key, it
      MUST abort the connection with an "illegal_parameter" alert.

   o  If the length of the "encrypted_server_name" extension is
      inconsistent with the advertised padding length (plus AEAD
      expansion) the server MAY abort the connection with an
      "illegal_parameter" alert without attempting to decrypt.

   Assuming that these checks succeed, the server then computes K_sni
   and decrypts the ServerName value.  If decryption fails, the server
   MUST abort the connection with a "decrypt_error" alert.

   If the decrypted value's length is different from the advertised
   padding_length or the padding consists of any value other than 0,
   then the server MUST abort the connection with an illegal_parameter
   alert.  Otherwise, the server uses the PaddedServerNameList.sni value
   as if it were the "server_name" extension.  Any actual "server_name"
   extension is ignored.

   Upon determining the true SNI, the fronting server then either serves
   the connection directly (if in Shared Mode), in which case it
   executes the steps in the following section, or forwards the TLS
   connection to the hidden server (if in Fronting Mode).



Rescorla                Expires November 13, 2018               [Page 8]

Internet-Draft           TLS 1.3 SNI Encryption                 May 2018


5.3.  Hidden Server Behavior

   The Hidden Server ignores both the "encrypted_server_name" and the
   "server_name" (if any) and completes the handshake as usual.  If in
   Shared Mode, the server will still know the true SNI, and can use it
   for certificate selection.  In Fronting Mode, it may not know the
   true SNI and so will generally be configured to use a single
   certificate Appendix A describes a mechanism for communicating the
   true SNI to the hidden server.  [[OPEN ISSUE: Do we want
   "encrypted_server_name" in EE?  It's clearer communication, but gets
   in the way of stock servers.]]

6.  Compatibility Issues

   In general, this mechanism is designed only to be used with servers
   which have opted in, thus minimizing compatibility issues.  However,
   there are two scenarios where that does not apply, as detailed below.

6.1.  Misconfiguration

   If DNS is misconfigured so that a client receives ESNI keys for a
   server which is not prepared to receive ESNI, then the server will
   ignore the "encrypted_server_name" extension, as required by
   [I-D.ietf-tls-tls13]; Section 4.1.2.  If the servers does not require
   SNI, it will complete the handshake with its default certificate.
   Most likely, this will cause a certificate name mismatch and thus
   handshake failure.  Clients SHOULD not fall back to cleartext SNI,
   because that allows a network attacker to disclose the SNI.  They MAY
   attempt to use another server from the DNS results, if one is
   provided.

6.2.  Middleboxes

   A more serious problem is MITM proxies which do not support this
   extension.  [I-D.ietf-tls-tls13]; Section 9.3 requires that such
   proxies remove any extensions they do not understand.  This will have
   one of two results when connecting to the fronting server:

   1.  The handshake will fail if the fronting server requires SNI.

   2.  The handshake will succeed with the fronting server's default
       certificate.

   A Web client client can securely detect case (2) because it will
   result in a connection which has an invalid identity (most likely)
   but which is signed by a certificate which does not chain to a
   publicly known trust anchor.  The client can detect this case and
   disable ESNI while in that network configuration.



Rescorla                Expires November 13, 2018               [Page 9]

Internet-Draft           TLS 1.3 SNI Encryption                 May 2018


   In order to enable this mechanism, fronting servers SHOULD NOT
   require SNI, but rather respond with some default certificate.

   A non-conformant MITM proxy will forward the ESNI extension,
   substituting its own KeyShare value, with the result that the
   fronting server will not be able to decrypt the SNI.  This causes a
   hard failure.  Detecting this case is difficult, but clients might
   opt to attempt captive portal detection to see if they are in the
   presence of a MITM proxy, and if so disable ESNI.  Hopefully, the TLS
   1.3 deployment experience has cleaned out most such proxies.

7.  Security Considerations

7.1.  Why is cleartext DNS OK?

   In comparison to [I-D.kazuho-protected-sni], wherein DNS Resource
   Records are signed via a server private key, ESNIKeys have no
   authenticity or provenance information.  This means that any attacker
   which can inject DNS responses or poison DNS caches, which is a
   common scenario in client access netowrks, can supply clients with
   fake ESNIKeys (so that the client encrypts SNI to them) or strip the
   ESNIKeys from the response.  However, in the face of an attacker that
   controls DNS, no SNI encryption scheme can work because the attacker
   can replace the IP address, thus blocking client connections, or
   substituting a unique IP address which is 1:1 with the DNS name that
   was looked up (module DNS wildcards).  Thus, allowing the ESNIKeys in
   the clear does not make the situation significantly worse.

   Clearly, DNSSEC (if the client validates and hard fails) is a defense
   against this form of attack, but DoH/DPRIVE are also defenses against
   DNS attacks by attackers on the local network, which is a common case
   where SNI.  Moreover, as noted in the introduction, SNI encryption is
   less useful without encryption of DNS queries in transit via DoH or
   DPRIVE mechanisms.

7.2.  Comparison Against Criteria

   [I-D.ietf-tls-sni-encryption] lists several requirements for SNI
   encryption.  In this section, we re-iterate these requirements and
   assess the ESNI design against them.

7.2.1.  Mitigate against replay attacks

   Since the SNI encryption key is derived from a (EC)DH operation
   between the client's ephemeral and server's semi-static ESNI key.
   This binds the ESNI encryption to the Client Hello.  It is not
   possible for an attacker to "cut and paste" the ESNI value in a




Rescorla                Expires November 13, 2018              [Page 10]

Internet-Draft           TLS 1.3 SNI Encryption                 May 2018


   different Client Hello, with a different ephemeral key share, as the
   terminating server will fail to decrypt and verify the ESNI value.

7.2.2.  Avoid widely-deployed shared secrets

   This design depends upon DNS as a vehicle for semi-static public key
   distribution.  Server operators may partition their private keys
   however they see fit provided each server behind an IP address has
   the corresponding private key to decrypt a key.  Thus, when one ESNI
   key is provided, sharing is optimally bound by the number of hosts
   that share an IP address.  Server operators may further limit sharing
   by including multiple keys, with distinct labels, in an ESNIKeys
   structure.

7.2.3.  Prevent SNI-based DoS attacks

   This design requires servers to decrypt ClientHello messages with
   EncryptedSNI extensions carrying valid labels.  Thus, it is possible
   for an attacker to force decryption operations on the server.  This
   attack is bound by the number of valid TCP connections an attacker
   can open.

7.2.4.  Do not stick out

   By sending SNI and ESNI values (with illegitimate labels), or by
   sending legitimate ESNI values for and "fake" SNI values, clients do
   not display clear signals of ESNI intent to passive eavesdroppers.
   As more clients enable ESNI support, e.g., as normal part of Web
   browser functionality, with keys supplied by shared hosting
   providers, the presence of ESNI extensions becomes less suspicious
   and part of common or predictable client behavior.  In other words,
   if all Web browsers start using ESNI, the presence of this value does
   not signal suspicious behavior to passive eavesdroppers.

7.2.5.  Forward secrecy

   This design is not forward secret since the server's ESNI key is
   static.  However, the window of exposure is bound by the key
   lifetime.  It is RECOMMEMDED that servers rotate keys frequently.

7.2.6.  Proper security context

   This design permits servers operating in Fronting Mode to forward
   connections directly to hidden origin servers, thereby avoiding
   unnecessary MiTM attacks.






Rescorla                Expires November 13, 2018              [Page 11]

Internet-Draft           TLS 1.3 SNI Encryption                 May 2018


7.2.7.  Fronting server spoofing

   Assuming ESNIKeys retrieved from DNS are validated, e.g., via DNSSEC
   or fetched from a trusted Recursive Resolver, spoofing a server
   operating in Fronting Mode is not possible.  See Section 7.1 for more
   details regarding cleartext DNS.

7.2.8.  Supporting multiple protocols

   This design has no impact on application layer protocol negotiation.
   It only affects connection routing, server certificate selection, and
   client certificate verification.  Thus, it is compatible with
   multiple protocols.

7.3.  Misrouting

   Note that the hidden server has no way of knowing what the SNI was,
   but that does not lead to additional privacy exposure because the
   hidden server also only has one identity.  This does, however, change
   the situation slightly in that the hidden server might previously
   have checked SNI and now cannot (and an attacker can route a
   connection with an encrypted SNI to any hidden server and the TLS
   connection will still complete).  However, the client is still
   responsible for verifying the server's identity in its certificate.

   [[TODO: Some more analysis needed in this case, as it is a little
   odd, and probably some precise rules about handling ESNI and no SNI
   uniformly?]]

8.  IANA Considerations

   This document has no IANA actions.

9.  References

9.1.  Normative References

   [I-D.ietf-tls-tls13]
              Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", draft-ietf-tls-tls13-28 (work in progress),
              March 2018.

   [RFC1035]  Mockapetris, P., "Domain names - implementation and
              specification", STD 13, RFC 1035, DOI 10.17487/RFC1035,
              November 1987, <https://www.rfc-editor.org/info/rfc1035>.






Rescorla                Expires November 13, 2018              [Page 12]

Internet-Draft           TLS 1.3 SNI Encryption                 May 2018


   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997, <https://www.rfc-
              editor.org/info/rfc2119>.

   [RFC6066]  Eastlake 3rd, D., "Transport Layer Security (TLS)
              Extensions: Extension Definitions", RFC 6066,
              DOI 10.17487/RFC6066, January 2011, <https://www.rfc-
              editor.org/info/rfc6066>.

   [RFC7540]  Belshe, M., Peon, R., and M. Thomson, Ed., "Hypertext
              Transfer Protocol Version 2 (HTTP/2)", RFC 7540,
              DOI 10.17487/RFC7540, May 2015, <https://www.rfc-
              editor.org/info/rfc7540>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://www.rfc-editor.org/info/rfc8174>.

9.2.  Informative References

   [I-D.ietf-doh-dns-over-https]
              Hoffman, P. and P. McManus, "DNS Queries over HTTPS",
              draft-ietf-doh-dns-over-https-07 (work in progress), April
              2018.

   [I-D.ietf-tls-sni-encryption]
              Huitema, C. and E. Rescorla, "SNI Encryption in TLS
              Through Tunneling", draft-ietf-tls-sni-encryption-02 (work
              in progress), March 2018.

   [I-D.kazuho-protected-sni]
              Oku, K., "TLS Extensions for Protecting SNI", draft-
              kazuho-protected-sni-00 (work in progress), July 2017.

   [I-D.schwartz-httpbis-dns-alt-svc]
              Schwartz, B. and M. Bishop, "Finding HTTP Alternative
              Services via the Domain Name Service", draft-schwartz-
              httpbis-dns-alt-svc-02 (work in progress), April 2018.

   [RFC7858]  Hu, Z., Zhu, L., Heidemann, J., Mankin, A., Wessels, D.,
              and P. Hoffman, "Specification for DNS over Transport
              Layer Security (TLS)", RFC 7858, DOI 10.17487/RFC7858, May
              2016, <https://www.rfc-editor.org/info/rfc7858>.







Rescorla                Expires November 13, 2018              [Page 13]

Internet-Draft           TLS 1.3 SNI Encryption                 May 2018


   [RFC8094]  Reddy, T., Wing, D., and P. Patil, "DNS over Datagram
              Transport Layer Security (DTLS)", RFC 8094,
              DOI 10.17487/RFC8094, February 2017, <https://www.rfc-
              editor.org/info/rfc8094>.

Appendix A.  Communicating SNI to Hidden Server

   As noted in Section 5.3, in Fronting Mode the hidden server will
   generally not know the true SNI.  It is possible for the fronting
   server to communicate the true SNI to the hidden server, but at the
   cost of having that communication not be unmodified TLS 1.3.  The
   basic idea is to have a shared key between the fronting server and
   the hidden server (this can be a symmetric key) and use it to send Z
   at the beginning of the connection before the ClientHello.  The
   hidden server can then decrypt ESNI to recover the true SNI.

   An obvious alternative here would be to have the fronting server
   forward the true SNI, but that would allow the fronting server to
   lie.  In this design, the attacker would need to be able to find a Z
   which would expand into a key that would validly AEAD-encrypt a
   message of his choice, which should be intractable (Hand-waving
   alert!).

Appendix B.  Alternate Encryption Design

   The design described here only provides encryption for the SNI, but
   not for other extensions, such as ALPN.  Another potential design
   would be to encrypt all of the extensions using the same basic
   structure as we use here for ESNI.  That design has the following
   advantages:

   o  It protects all the extensions from ordinary eavesdroppers

   o  If the encrypted block has its own KeyShare, it does not
      necessarily require the client to use a single KeyShare, because
      the client's share is bound to the SNI by the AEAD (analysis
      needed).

   It also has the following disadvantages:

   o  The fronting server can still see the other extensions.  By
      contrast we could introduce another EncryptedExtensions block that
      was encrypted to the hidden server and not the fronting server.

   o  It requires a mechanism for the fronting server to provide the
      extension-encryption key to the hidden server (as in Appendix A
      and thus cannot be used with an unmodified hidden server.




Rescorla                Expires November 13, 2018              [Page 14]

Internet-Draft           TLS 1.3 SNI Encryption                 May 2018


   o  A conformant middlebox will strip every extension, which might
      result in a ClientHello which is just unacceptable to the server
      (more analysis needed).

Acknowledgments

   This document draws extensively from ideas in
   [I-D.kazuho-protected-sni], but is a much more limited mechanism
   because it depends on the DNS for the protection of the ESNI key.
   Richard Barnes, Christian Huitema, Patrick McManus, Matthew Prince,
   Nick Sullivan, Martin Thomson, and Chris Wood also provided important
   ideas.

Author's Address

   Eric Rescorla
   RTFM, Inc.

   Email: ekr@rtfm.com
































Rescorla                Expires November 13, 2018              [Page 15]
